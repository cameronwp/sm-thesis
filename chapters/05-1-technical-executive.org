#+title: Technical - Executive

* COMMENT extra
** notes on kirk from jake

Kirk operates on qualitative state plans, which consist of episodes that organize the occurrance of
events as activities. Also includes causal links (:effects and :requires ala STRIPS/PDDL planning).
All passed to OpSAT, which is like an SMT solver. Makes choices through causal links to decompose
state constraints into a SAT problem and then solve. Temporal constraints go to
temporal-controllability. State plan gets turned into a SAT solver, with ordering from temporal
constraints.

* An Executive for Scheduling with Observation Delay
<<ch:technical-executive>>

A delay scheduler is only useful if there is a system capable of dispatching the actions associated
with RTEDs. A delay scheduler could be integrated as a subsystem for a digital assistant, if such a
digital assistant has a means for surfacing RTEDs to a user in a useful manner. Instead, for this
thesis, we choose to integrate with a high-level task and motion planner, /Kirk/
[cite:@Williams2003]. Kirk is a complete, end-to-end executive in that it can take human-friendly
problem specifications as input and send commands to hardware as output.

At a high-level, Kirk operates by first taking a description of the problem domain as written by
domain experts, which should include the constraints, agent dynamics, environment, and starting and
goal states of the problem at hand. Kirk then generates state plans, which consist of episodes that
organize the occurrence of events as activities. State plans may include temporal constraints and
non-temporal constraints, such as classical planning preconditions and effects. Kirk checks plans
for consistency using an optimal satisfiability (OpSAT) solver [cite:@Williams2007]. Next, it
elaborates temporal plan networks (TPNs) [cite:@Kim2001] to sub-executives when it encounters
constraints and goals it cannot plan against directly. Finally, it dispatches actions to hardware.
For the purpose of this thesis, we focus on Kirk's capability to dispatch actions from state plans.

Below, we present an instantiation of Kirk, /Delay Kirk/, designed to dispatch actions from state
plans with uncertain observations. A delay scheduler lives at the core of Delay Kirk, with a new
component, a /delay dispatcher/ taking responsibility for translating RTEDs into actions in the real
world. In this chapter, we start by defining a delay dispatcher, which plays a key role in enabling
delay scheduling. Next, we present a high-level overview of Kirk's architecture. Finally, we define
necessary components of an input language, the Reactive Model-Based Programming Language (RMPL),
used to represent constraints and action models for Delay Kirk. We present experimental results on
the performance of the delay dispatcher, however, experimentation with a full Delay Kirk executive
are presented in Section [[sec:ma-experimental]].

** Dynamic Dispatching of STNUs with Observation Uncertainty
<<sec:delay-scheduler>>

We assume that events in an STNU map one-to-one with actions in the real world. To put the design of
the dispatcher in context, it is worth considering what events may look like. In the case of a
robotic agent, requirement events may represent the instantaneous timepoints when motion plans
begin, while contingent events could be anything from the completion of said motion plans to the
receipt of =PROCEED= messages from a third party. For a human, requirement events could be presented
in a mission timeline as the start of planned actions such as the collection of scientific samples.
The end of a sampling activity would then be an uncontrollable event. Or uncontrollable events could
be the actions performed by other agents, like say another astronaut on an EVA, with whom temporal
constraints are shared. In both the case of the robot and the human, a robust dispatcher should take
into consideration that passing a message to the agent telling it to execute a requirement event
does not cause the event to occur instantaneously. Put in other words, we are not guaranteed that
dispatching an action causes an event to be scheduled instantaneously. A robot may require offline
processing before it executes the motion plan. Or a human may need to acknowledge that they have
started the action their digital assistant has instructed them to perform. Neither situation is a
problem for our chosen formalism for temporal reasoning so long as each requirement event is
assigned at some point within their constraints in the STNU. In our view, the dispatcher is
responsible for ensuring requirement constraints are met by both monitoring the real-world and
interfacing with hardware to cause actions to be performed.

#+label: fig:executive-dispatching-architecture
#+attr_latex: :width 0.6\textwidth
#+caption: A more detailed view of the delay dispatcher architecture.
file:../images/architecture.png

As depicted in Figure [[fig:executive-dispatching-architecture]], there are two key pathways within a
delay dispatcher. First, a delay dispatcher takes an RTED as input and causes actions to happen in
the environment as output. Second, it takes event observations as input and may cause the scheduler
to record events as output.

Additionally, we introduce a sub-component, a /driver/, that can interpret dispatched events and
cause some action to be performed in the environment. We separate the driver and delay dispatcher in
Figure [[fig:executive-dispatching-architecture]] for completeness, however, for all intents and
purposes, the driver is a sub-component of a delay dispatcher. A driver is defined as performing the
following transformation: given some event, $x$, as input the driver should cause an action to be
performed. For instance, if Delay Kirk is controlling a robotic manipulator over ROS, the driver
would receive an event string as input and publish ROS messages as output.

In this Section, we contribute a set of algorithms for building the dispatcher for a robust
executive that can reason over observation delay and safely enact the actions symbolized in
requirement events in the real world. We focus on the interpretation, management, and flow of RTEDs
in Section [[sec:dynamic-dispatching]]. In Section [[sec:event-observations]] we describe the process of
observing events. But first, we present a novel view on RTEDs that is required for dispatching
events to real hardware in Section [[sec:real-vs-noop-events]].

*** Guaranteeing Agents Receive Actionable Events
<<sec:real-vs-noop-events>>

# In our view, RTEDs are not commands to the agent. Rather, they inform the executive of the
# time where actions ensure consistency.

We take the view that events in an STNU may be interpreted as commands by the driver. It is improper
to knowingly send an invalid command. Accordingly, the driver must never receive an event (in an
RTED) that cannot be mapped to a corresponding action in its environment. As such, it is the
dispatcher's responsibility to filter events in order to only dispatch valid actions.

In a variable-delay STNU, there are events that are associated with actions and there are events
that are not. We call these /real/ and /no-op/ ("no operation") events. Only controllable events may
be real, but both uncontrollable /and/ controllable events may be no-op. Below, we present our
rationale for the distinction between real and no-op events, and how we modify real-time execution
decisions accordingly.

To start, imagined uncontrollable events are no-ops. They are assignments we artificially perform
with no corresponding real-world action, and solely exist to maintain the controllability of the
fixed-delay dispatchable form. Imagined events should never be dispatched to a driver.

There are requirement events that are also no-ops. Consider the process of normalization of an STNU
[cite:@Morris2006]. While building the labeled distance graph during a DC check, we rewrite
contingent links such that their lower bounds are always $0$. For instance, for an uncontrollable
event $C$ and requirement event $E$, $C - E \in [l, u]$, during normalization we create a new
requirement event, $C'$, fixed at the lower bound of the contingent link, and then shift the bounds
of the contingent link to start at 0 while maintaining the original range, $u - l$. This results in
two constraints: $E - C' \in [l, l]$ and $C - C' \in [0, u - l]$. The original contingent link's
semantics are thus maintained.

Importantly, the requirement events representing the normalized lower bounds of uncontrollable
events are in the dispatchable form for dynamic scheduling because we draw the AllMax graph directly
from the DC check. To a scheduler, there is no distinction between the semantics of a real event, as
modeled by a human planner writing an STNU for an agent to execute, and $C'$, an artifact of
checking controllability. Both are modeled in the AllMax distance graph forming the basis of RTED
generation. However, an agent cannot dispatch any action to satisfy $E - C'$, rather $C'$ should
simply be scheduled at the appropriate time. Thus, we make the following addendum to the definition
of RTEDs.

#+begin_export latex
\newcommand*{\eventnoop}{\mathit{event}\textsf{-}\mathit{noop}}
\newcommand*{\eventnoops}{\mathit{event}\textsf{-}\mathit{noops}}
#+end_export

# TODO these variables aren't great
#+label: def:rted
#+latex: \begin{defn}
*Event-No-op Pair*

An /Event-No-op Pair/, $\eventnoop$, is a two-tuple, $\langle x, \mathit{noop} \rangle$,
where:
- $x$ is an event in $X_{e} \cup X_{c}$,
- /noop/ is a boolean, where if true, the event cannot be interpreted by the driver, else the event
  is a valid command.
#+latex: \end{defn}

#+label: def:rted-op
#+latex: \begin{defn}
#+latex: \label{def:rted-op}
*RTED with Operational Distinction*

A /Real-Time Execution Decision with Operational Distinction/ is a tuple $\langle t, \eventnoops
\rangle$, where:
- $t$ is a time with domain $\mathbb{R}$,
- $\eventnoops$ is a set of $\eventnoop$ pairs to be executed at time $t$.
#+latex: \end{defn}

For convenience and simplicity, and given the similarities between RTED and RTED with Operational
Distinction, future references to RTEDs will always refer to RTEDs with Operational Distinctions.

*** Dispatching Actions Dynamically
<<sec:dynamic-dispatching>>

The dynamic dispatcher runs the main loop of the executive's temporal reasoning routine. It consists
of a dispatching routine and some type of outer loop monitoring it. The dispatching routine,
Algorithm [[alg:dispatcher-inner]], is responsible for retrieving the latest RTEDs and dispatching
actions when the clock indicates that the agent has reached time $t$ corresponding to the latest
RTED. The outer loop allows the dispatching routine to run until the scheduler reports there are no
requirement events remaining.

# The dispatcher requests RTEDs with blocking synchronous calls, while the dispatcher and driver
# communicate asynchronously. The dispatcher spawns a thread to make non-blocking calls to the
# driver's interface to execute events. The dispatcher and driver also share a FIFO queue that the
# driver can append messages to indicating the successful execution of events.
# TODO is the part about non-blocking calls to the driver true? does it matter?

We now provide a walkthrough of the dynamic dispatching algorithm. For simplicity's sake, the term
/schedule/ here is shorthand for whatever data structures the scheduler uses to generate RTEDs.
/Updating the schedule/ refers to running the fixed-delay FAST-EX update, Algorithm
[[alg:fast-ex-fixed-obs]], using the variable-delay execution strategy from Section
[[sec:delay-scheduling]].

The interaction between the dispatching routine and monitoring loop is limited. Algorithm
[[alg:dispatcher-inner]] returns a Boolean indicating whether there are executable events remaining.
Here, the monitoring loop, Algorithm [[alg:dispatcher-outer]] is a simple =while= that repeats until it
receives =false= from the inner loop.

We break the dispatching routine into three distinct phases.

1. Observe events that were executed.
2. Collect events from the RTED and events that have been buffered that should be dispatched at this
   time.
3. If there are events to be dispatched:
   a. send real events to the driver, and
   b. immediately assign all /no-op/ events to the current time.

Our goal in the dispatching routine is to dispatch events to the driver only after updating the
schedule, collecting an up-to-date RTED, checking for buffered events, and confirming we are within
the time window of the actions to be dispatched. The routine will exit before reaching the dispatch
step if any conditions are not met.

For the first step, we ask the scheduler if there are any remaining executable events. If there are
none, we return =false= to signal the loop's termination, otherwise we continue.

Next, we observe events associated with actions that have been dispatched by the driver. We choose
to use a FIFO queue to store messages corresponding to event observations from the driver. The
presence of a message would indicate that the driver has successfully executed a free event. We
iteratively pop messages off the queue and update the schedule with the events and execution time
contained in each message. Note that the scheduler update is a blocking operation because we need an
up-to-date schedule to guarantee future RTEDs are consistent.

The second step begins once we have popped all messages from the driver off the queue. We need to
decide what events will be dispatched as actions next. Given the relationship between the scheduler,
routine, and driver, we do not assume that dispatched actions are executed instantaneously by the
driver. We know that execution contends against delays such as the computational time in simply
calling a function, to network latency, to robotic hardware that takes a moment to interpolate a
motion plan from waypoints. In some contexts, it may make sense to preempt execution by dispatching
events some small amount of time /before/ the clock time reaches the RTED execution window. We call
this preemption time $\epsilon$, where $\epsilon \in \mathbb{R}^{\geq 0}$. If $\epsilon = 0$, the
dispatcher is not allowed to preemptively dispatch actions before the RTED time. The value of
$\epsilon$ should be dependent on the operational domain of the driver.

What distinguishes a delay dispatcher from a dispatcher that would work with instantaneous
observations is a delay dispatcher's handling of buffered events (see Lemma
[[lemma:buffering-imagining]]). Given we left no facility in the delay scheduler to track events that
need to be buffered, a delay dispatcher must take responsibility for buffered events. A delay
dispatcher should record which events need to be buffered, and how long they should be buffered.

Algorithm [[alg:choose-event-noops]] provides a subroutine in which we compare a new RTED and any
buffered events to the history of actions dispatched so far. Let $t$ be the current time. It outputs
a set of \eventnoops consisting of:

1. any event buffered to $t$,
2. real events of the RTED if $t_{\mathit{RTED}} = t \leq \epsilon$, and
3. no-op events of the RTED if $t_{\mathit{RTED}} = t$.

Buffered events are always no-ops given that they are uncontrollable events observed earlier, hence
we do not need to preempt them with $\epsilon$. No-op events in the RTED should not be preempted
either. Only real events should be preempted.

A history of actions is necessary to avoid dispatching the same action more than once. If the
dispatcher loop is running quickly and actions are dispatched asynchronously, then the loop may
iterate one or more times between dispatching an action and observing its associated event.

If Algorithm [[alg:choose-event-noops]] returns no $\eventnoop$ pairs, we end this iteration by
returning =true=.

Once we reach the third stage, we are guaranteed to be able to dispatch valid actions because (1) we
have confirmed that the $\eventnoops$ we have in hand have never been dispatched, and (2) we are in
a time window that the scheduler has told us is consistent with the STNU's constraints. We filter
the $\eventnoop$ pairs into a set of no-op events and a set of real events. In the event that an
uncontrollable event and its normalized lower bound (both no-ops) are to be scheduled at the same
time, we schedule the normalized lower bound first first. Real events are then asynchronously sent
to the driver.

All $\eventnoops$ that were dispatched are added to the history to prevent them from being
dispatched again. Finally, because events were dispatched, the dispatching routine returns =true=.

We benefit greatly from using instance-based properties. The implementation of the delay dispatcher
for this thesis uses slots on a =dispatcher= class to manage inputs to the dispatcher, which are
then accessed by reference. All inputs to Algorithm [[alg:dispatcher-outer]] can be properties on an
instance of a delay dispatcher class.

#+label: alg:dispatcher-outer
#+begin_export tex
\begin{algorithm}
\SetAlgoLined
\SetKwComment{Comment}{//}{}
\SetKwFunction{Return}{return}
\SetKwInput{Input}{Input}
\SetKwInput{Output}{Output}
\SetKwInput{Algorithm}{\textsc{Dynamic Dispatching Outer Loop}}
\SetKwInput{Initialize}{Initialization}
\SetKwIF{If}{ElseIf}{Else}{if}{then}{else if}{else}{endif}
\SetKw{Continue}{continue}

\Indm
\Input{}

\Initialize{Hash-table \texttt{buffered-events} $\gets \varnothing$; Set \texttt{history} $\gets \varnothing$}

\Indp
\Algorithm{}
\Indp

\texttt{all-inputs} \gets \langle \texttt{buffered-events}, \texttt{history}, \textit{Scheduler}, \textit{Driver}, \textit{Queue}, \textit{Clock}, \epsilon \rangle\;

\While{Calling inner loop with \texttt{all-inputs} returns true} {
    \Continue
}
\caption{The outer loop of the dynamic dispatching algorithm.}
\label{alg:dispatcher-outer}
\end{algorithm}
#+end_export

#+label: alg:choose-event-noops
#+begin_export tex
\begin{algorithm}
\SetAlgoLined
\SetKwComment{Comment}{//}{}
\SetKwFunction{Return}{return}
\SetKwInput{Input}{Input}
\SetKwInput{Output}{Output}
\SetKwInput{Algorithm}{\textsc{Choose Event-Noops}}
\SetKwInput{Initialize}{Initialization}
\SetKwIF{If}{ElseIf}{Else}{if}{then}{else if}{else}{endif}

\Indm
\Input{\texttt{RTED}; \texttt{buffered-events}; a set of dispatched event-noops \texttt{history}; \epsilon; current time $t$}
\Output{Set of event-noops}

\Initialize{\texttt{event-noops} \gets \varnothing\;}

\Indp
\Algorithm{}
\Indp

\If{t is a key in \texttt{buffered-events}} {
    \texttt{event-noops} $\gets$ event-noops from \texttt{buffered-events}[$t$]\;
}

\If {$\mathtt{RTED}[time] = t$} {
    Add no-op \texttt{RTED}[event-noops] to \texttt{event-noops}\;
}

\If {$t - \mathtt{RTED}[time] \leq \epsilon$} {
    Add real \texttt{RTED}[event-noops] to \texttt{event-noops}\;
}

Remove any event-noops in \texttt{event-noops} that are in \texttt{history}\;

\Return \texttt{event-noops}\;

\caption{An algorithm for paring the events from an RTED and buffered events into \eventnoops.}
\label{alg:choose-event-noops}
\end{algorithm}
#+end_export


#+label: alg:dispatcher-inner
#+begin_export tex
\begin{algorithm}
\SetAlgoLined
\SetKwComment{Comment}{//}{}
\SetKwFunction{Return}{return}
\SetKwInput{Input}{Input}
\SetKwInput{Output}{Output}
\SetKwInput{Algorithm}{\textsc{Dynamic Dispatching Routine}}
\SetKwInput{Initialize}{Initialization}
\SetKwIF{If}{ElseIf}{Else}{if}{then}{else if}{else}{endif}

\Indm
\Input{Current time $t$, $\texttt{buffered-events}; \texttt{history}; \mathit{Scheduler}; \mathit{Driver}; \mathit{Queue}; \mathit{Clock}; \epsilon$;}
\Output{Boolean whether the outer loop should continue}

\Initialize{\texttt{real-events} $\gets$ \{\}; \texttt{noop-events} $\gets$ \{\}; $t$ \gets current time of \textit{Clock};}

\Indp
\Algorithm{}
\Indp

\If{\mathit{Scheduler} has no more unexecuted events} {
    \Return false\;
}

\For{message in \mathit{Queue}} {
    Pop message\;
    \For{event, $t_{\mathit{execution}}$ in message} {
        Update \textit{Scheduler} with observation of event at $t_{execution}$\;
    }
}

\texttt{RTED} $\gets$ a new RTED from \textit{Scheduler}; \Comment{Equations \ref{eqn:rted-chi} and \ref{eqn:rted-t}}

\texttt{event-noops} \gets \texttt{choose-event-noops(RTED, buffered-events, history}, \epsilon, \textit{t}\texttt{)}\;

\If{no \texttt{event-noops}} {
    \Return true\;
}

\For{\texttt{event-noop} pair in \texttt{event-noops}} {
    \eIf{\texttt{event-noop}[noop] is \textbf{true}} {
        Add \texttt{event-noop}[event] to \texttt{noop-events}\;
    } {
        Add \texttt{event-noop}[event] to \texttt{real-events}\;
    }
}

Sort \texttt{noop-events} such that normalized lower bounds have the lowest indices;

\For{event in \texttt{noop-events}} {
    Update \textit{Scheduler} with observation of event at $t$\;
}

Asynchronously send all \texttt{real-events} to the \textit{Driver}\;

Add \texttt{event-noops} to \texttt{history}\;

\Return true\;

\caption{The dynamic dispatching routine.}
\label{alg:dispatcher-inner}
\end{algorithm}
#+end_export

The biggest factor for the performance of the dispatching routine, Algorithm
[[alg:dispatcher-inner]], is updating the schedule. Assuming the /Scheduler/ is the Delay Scheduler
described in Section [[sec:delay-scheduler]], then performing an assignment of an event will trigger the
FAST-EX update that runs in $O(N^{3})$ [cite:@Hunsberger2016 p144] with the number of events in the
STNU. In the worst case, the dispatcher confirms that all events in the STNU have arrived at the
same time, whether as messages from the driver in the FIFO queue, or RTED =noop= events. Each event
would trigger a schedule update. Thus, the dynamic dispatching routine runs in $O(N^{4})$ in the
worst case.

*** Observing Contingent Events
<<sec:event-observations>>

The dispatcher relays contingent event observations to the scheduler. In the base case, when a
contingent event is observed, the dispatcher updates the schedule with the event and current clock
time.

If the observed event is uncontrollable and arrived earlier than its lower bound, then the
dispatcher will save the event in a =buffered-events= hash-table with the lower bound of its
constraint as the key. By Lemma [[lemma:buffering-imagining]], the lower bound will be $l^+(x_{c})$ for
some uncontrollable event $x_{c}$.

*** Experimental

Finally, we benchmark action dispatching. In our simulated environments for dispatching, we run the
dispatcher function as described in Algorithm [[alg:dispatcher-inner]] twice per simulated second. (We
run it twice in the event that scheduling an event enables us to dispatch other actions immediately.
If we ran Algorithm [[alg:dispatcher-inner]] once per second, the newly enabled events would then be
dispatched a second late.)

Given every event will be scheduled once using the FAST-EX update, FAST-EX updates will dominate the
total runtime of dispatching. As seen in Figure [[fig:runtime-tick-aggregate]], the total runtime of all
calls to Algorithm [[alg:dispatcher-inner]] indeed follows $O(N^{2} \log N)$.

#+label: fig:runtime-tick-aggregate
#+attr_latex: :width 0.8\textwidth
#+caption: Average runtime data for running Algorithm [[alg:dispatcher-inner]].
file:../images/tick-total-runtime.png
** Architecture

We present a view of the Delay Kirk architecture that focuses attention to its scheduling and
dispatching capabilities. Kirk takes RMPL [cite:@RMPL2002] as input and produces actions as output
(from here on, "Kirk" refers to Delay Kirk because the architectural design of Delay Kirk and other
Kirks is fundamentally the same). As shown in Figure [[fig:executive-kirk-architecture]], there are
three key components of Kirk.

#+label: fig:executive-kirk-architecture
#+attr_latex: :width 0.6\textwidth
#+caption: A simplified, high-level overview of the Delay Kirk task executive architecture with respect to dispatching actions.
file:../images/executive-architecture.png

Figure [[fig:executive-kirk-architecture]] explicitly identifies the environment. We do so to highlight
that Kirk is designed to be able to interact with the outside world. For instance, if Kirk is
running on a robot, the environment might consist of the pose of the manipulator and any objects in
the scene. If Kirk is responsible for sending notifications to a digital assistant in a spacesuit,
then the environment might be the "as executed" version of an EVA timeline. In either case, actions
caused by Kirk will impact the environment. Likewise, Kirk learns from the environment. Here we show
event observations from the environment being sent to the scheduler. However, when Kirk is working
with sub-executives designed for specific problem domains, e.g. risk-bounded motion planning, it may
be monitoring other aspects of the environment as well.

Every Kirk has a planning component that takes RMPL as input, generates state plans, then checks
consistency using OpSAT. OpSAT is similar to a satisfiability (SAT) solver with the property that it
produces optimal assignment to real valued variables. Any temporal constraints in the state plan are
translated to a delay STNU then checked with the variable-delay controllability checker from Chapter
[[ch:modeling-tn]].

If the overall state plan is satisfiable, it is then sent to the delay scheduler. Note that earlier
we have said that the delay scheduler takes a temporal network as input. However, Figure
[[fig:executive-kirk-architecture]] shows a state plan as input to the delay scheduler. Functionally,
there is no difference. There is a one-to-one relationship between state plans and delay STNUs. In
fact, as implemented for this thesis, the delay scheduler can take either a state plan or delay STNU
as input. If a state plan is received, then the first action taken is to convert the state plan to a
delay STNU.

RTEDs that the delay scheduler outputs are sent to a delay dispatcher.

** RMPL
<<sec:rmpl>>

# TODO better explanation
RMPL [cite:@Williams2003] is a key component of Kirk. This section steps through example RMPL
control programs to describe their features and our modeling choices. The purpose of this section is
two-fold:

1. We must describe the modeling choices of RMPL in sufficient detail to make concrete our approach
   to modeling temporal constraints in human-readble form for the experiments in Sections
   [[sec:dkirk-simulation]] and [[sec:hw-demo]]
2. The above is used to demonstrate that modeling uncertain communication delay can be naturally
   modeled in RMPL.

This section is not meant to be a complete documentation of RMPL, rather our goal is to motivate the
strength of RMPL as a modeling language for human planners describing autonomous systems with
observation uncertainty.

RMPL has undergone a number of rewrites since its inception, and is currently being developed as a
superset of the Common Lisp language using the Metaobject Protocol [cite:@Kiczales1991]. The goal is
that a human should have a comfortable means for accurately modeling sufficient detail about the
problem domain such that an executive can perform model-based reasoning to decide how to act.

# TODO does this sentence go with the paragraph above?
# RMPL should /never/ include explicit programming instructions for the executive.

An example of an RMPL control program for a single-agent without agent dynamics follows in Listing
[[code:example-control-program]].

#+name: code:example-control-program
#+caption: A sample control program composed of three constraints. =eat-breakfast= and =bike-to-lecture= designate controllable constraints, while the =main= control program enforces that the constraints are satisfied in series.
#+begin_src lisp
;; NOTE: we omitted Lisp package definitions here for simplicity's sake

(define-control-program eat-breakfast ()
  (declare (primitive)
           (duration (simple :lower-bound 15 :upper-bound 20))))

(define-control-program bike-to-lecture ()
  (declare (primitive)
           (duration (simple :lower-bound 15 :upper-bound 20))))

(define-control-program main ()
  (with-temporal-constraint (simple-temporal :upper-bound 40)
    (sequence (:slack nil)
              (eat-breakfast)
              (bike-to-lecture))))
#+end_src

Looking past the parentheses, we can see different options for defining temporal constraints. For
example, the =(duration (simple ...))= form is used to define a set-bounded temporal constraint
between a =:lower-bound= and an =:upper-bound=. The =main= control program uses a different form,
=(with-temporal-constraint ...)= to place an =:upper-bound= on the overall deadline for scheduling
all events in the control program.

The example control programs in Listing [[code:example-control-program]] are defined without agents in
that there is an assumption that the Kirk instance that executes this control program must know what
the semantics of =eat-breakfast= and =bike-to-lecture= mean and how to execute them.

Each constraint is represented as an episode of a start and end event, e.g. =eat-breakfast= becomes
$\edge{\texttt{eat-breakfast:start}}{\texttt{eat-breakfast:end}}{[15, 20]}$.

It could also be the case that Kirk is simply being used to produce a schedule of events offline
that will be handed to an agent that knows how to execute them. As an example, perhaps a student
wants some help planning their morning, so they write an RMPL control program with constraints
representing everything they need to do between waking up and going to lecture, as seen in the more
complex control program in Listing [[code:morning-lecture]]. The student could ask Kirk to produce a
schedule of events that satisfies all the temporal constraints in this RMPL control program, which
they would then use to plan their morning routine. See the resulting schedule produced by Kirk in
Table [[tab:morning-lecture-schedule]]. (Note that while normally times in RMPL are represented in
seconds, we use minutes in Listing [[code:morning-lecture]] and Table [[tab:morning-lecture-schedule]] for
simplicity's sake.)

#+name: code:morning-lecture
#+caption: A student's morning routine preparing for lecture as modeled in RMPL. This is a complete RMPL program that includes the required Lisp package definitions to run in Kirk.
#+begin_src lisp -n -r
;; This file lives in the thesis code repo at:
;;      kirk-v2/examples/morning-lecture/script.rmpl
;;
;; To execute this RMPL control program as-is and generate a schedule, go to the root
;; of the thesis code repo and run the following command:
;;
;; kirk run kirk-v2/examples/morning-lecture/script.rmpl \
;;      -P morning-lecture \
;;      --simulate

(rmpl/lang:defpackage #:morning-lecture)

(in-package #:morning-lecture)

(define-control-program shower ()
  (declare (primitive)
           (duration (simple :lower-bound 5 :upper-bound 10))))

(define-control-program eat-breakfast ()
  (declare (primitive)
           (duration (simple :lower-bound 15 :upper-bound 20))))

(define-control-program review-scheduling-notes ()
  (declare (primitive)
           (duration (simple :lower-bound 10 :upper-bound 15))))

(define-control-program review-planning-notes ()
  (declare (primitive)
           (duration (simple :lower-bound 10 :upper-bound 15))))

(define-control-program pack-bag ()
  (declare (primitive)
           (duration (simple :lower-bound 5 :upper-bound 6))))

(define-control-program bike-to-lecture ()
  (declare (primitive)
           (duration (simple :lower-bound 15 :upper-bound 20))))

(define-control-program review-notes ()
  (sequence (:slack t)
    (review-scheduling-notes)
    (review-planning-notes)))

(define-control-program main ()
  (with-temporal-constraint (simple-temporal :upper-bound 60)
    (sequence (:slack t)
      (shower)
      (parallel (:slack t) (ref:parallel)
        (eat-breakfast)
        (review-notes))
      (pack-bag)
      (bike-to-lecture))))
#+end_src

#+name: tab:morning-lecture-schedule
#+caption: The schedule produced by Kirk's scheduler for the student's routine before lecture as modeled in Listing [[code:morning-lecture]]. Note: Kirk's output has been cleaned for readability purposes.
#+ATTR_LATEX: :align left
| *Event*                         | *Time (min)* |
|---------------------------------+--------------|
| =START=                         |            0 |
| Start =shower=                  |            1 |
| End =shower=                    |            6 |
| Start =review-scheduling-notes= |            6 |
| Start =eat-breakfast=           |            6 |
| End =review-scheduling-notes=   |           16 |
| Start =review-planning-notes=   |           16 |
| End =eat-breakfast=             |           21 |
| End =review-planning-notes=     |           26 |
| Start =pack-bag=                |           26 |
| End =pack-bag=                  |           31 |
| Start =bike-to-lecture=         |           32 |
| End =bike-to-lecture=           |           46 |
| =END=                           |           46 |

Listing [[code:morning-lecture]] introduces the notion of control programs that are allowed to be
executed simultaneously, as modeled with the =(parallel ...)= form found in the =main= control
program on line [[(parallel)]].

Kirk is able to simulate the RMPL script in Listing [[code:morning-lecture]] and produce a schedule
because there were no uncontrollable constraints, that is, all control programs are under the
agent's control. Say we replaced =bike-to-lecture= with =drive-to-lecture=. Due to traffic
conditions, driving presents in an uncontrollable constraint. RMPL allows us to model uncontrollable
constraints as in Listing [[code:drive-to-lecture]].

#+name: code:drive-to-lecture
#+caption: An uncontrollable, or contingent, temporal constraint in a control program.
#+begin_src lisp
(define-control-program drive-to-lecture ()
  (declare (primitive)
           (duration (simple :lower-bound 15 :upper-bound 20)
                     :contingent t)))
#+end_src

The addition of =:contingent t= to the =(duration ...)= form tells Kirk that =drive-to-lecture:end=
is an uncontrollable event. With the instantiation of Kirk used for this thesis, observations of
=drive-to-lecture:end= could come in the form of user interactions, HTTP POST requests, or a
pre-determined list of event observations given to Kirk.

As a contribution of this thesis, our existing approach to specifying durations in RMPL was expanded
to model observation delay. An example follows in Listing [[code:rmpl-obs-delay]] modeling a sample
collection control program with observation delay.

#+name: code:rmpl-obs-delay
#+caption: An RMPL control program describing a science data collection task with observation delay.
#+begin_src lisp
(define-control-program collect-science-sample ()
  (declare (primitive)
           (duration (simple :lower-bound 15 :upper-bound 30
                             :min-observation-delay 5
                             :max-observation-delay 15)
                     :contingent t)))
#+end_src

We can see in Listing [[code:rmpl-obs-delay]] that representing set-bounded observation delay is a
simple as adding =:min-= and =:max-observation-delay= to the =(duration (simple ...) :contingent t)=
form.

See Appendix [[appendix:rmpl]] for further discussion of RMPL.
