#+title: Appendix - RMPL to STNUs

* Additional RMPL Information
<<appendix:rmpl>>

Modeling constraint programs in RMPL was required for the multi-agent demonstrations of a delay
scheduler. We include additional information on RMPL below.

** Control Programs and STNUs

Key to the challenge of being a mission planner is to understand the constraints between events.
RMPL is an abstraction layer, meaning that it will interpret RMPL and produce a delay STNU
reflecting its own interpretation, which may not align with the mission planner's intention. We have
seen students in the lab be surprised by the temporal constraints generated by RMPL, and, through
the experiments involved in this thesis, have also found RMPL to be less-than-intuitive on occasion.
The chief cause of confusion is a disjoint between the fundamental unit of temporal reasoning, the
temporal event, and the fundamental unit of RMPL control programs, the episode, which consists of a
start and an end event. This is not a limitation of the semantics of RMPL, rather, it is a naming
issue.

To elaborate, temporal reasoning literature emphasizes events as meaningful timepoints. For
instance, we used numbered =Confirm:0:0= events to represent the end of an installation task in
Sections [[sec:scheduling-experimental]] and [[sec:dkirk-simulation]], while the start of the task was an
=Install:0:0= event, e.g. $\conedge{\texttt{Install:0:0}}{\texttt{Confirm:0:0}}{[l, u]}$. Depending
on the size of the generated STNU, the =Confirm:0:= event then had outgoing edges to events such as
=Start:0:1=, =Install:1:0=, or =ALL:END=. In RMPL, however, a representation of this constraint
between events with these names is impossible.

Consider the following control program.

#+begin_src lisp
(define-control-program take-pictures ()
  (declare (primitive)
           (duration (simple :lower-bound 1 :upper-bound 5))))
#+end_src

We have defined an episode named =take-pictures=. It represents a requirement constraint in the form
of $\edge{\texttt{take-pictures:start}}{\texttt{take-pictures:end}}{[1, 5]}$. Note that the one
episode led to the creation of two events. We now add a second episode and show the two options RMPL
gives us for joining them in series.

#+begin_src lisp
(define-control-program eat-snack ()
  (declare (primitive)
           (duration (simple :lower-bound 3 :upper-bound 7))))

;; Sequence option 1
(define-control-program with-slack ()
  (with-temporal-constraint (simple-temporal :lower-bound 6 :upper-bound 10)
    (sequence (:slack t)
              (take-pictures)
              (eat-snack))))

;; Sequence option 2
(define-control-program no-slack ()
  (with-temporal-constraint (simple-temporal :lower-bound 6 :upper-bound 10)
    (sequence (:slack nil)
              (take-pictures)
              (eat-snack))))
#+end_src

We have two commonly used options for =:slack= in the sequence, =(:slack nil)= and =(:slack t)=. If
slack is applied, episodes are connected with $[0, \infty]$ constraints, effectively guaranteeing
episode ordering without enforcing that the latter episode must start immediately after the first.
Ignoring the overall constraint, the two control programs are connected like so.

$$
\edge{\texttt{take-pictures:start}}{\texttt{take-pictures:end}}{[3, 7]} \edge{}{\texttt{eat-snack:start}}{[0, \infty]} \edge{}{\texttt{eat-snack:end}}{[3, 7]}
$$

Without slack, the constraints are arranged as follows.

$$
\edge{\texttt{take-pictures:start}}{\texttt{take-pictures:end}}{[3, 7]} \edge{}{\texttt{eat-snack:start}}{[0, 0]} \edge{}{\texttt{eat-snack:end}}{[3, 7]}
$$

The RMPL compiler takes it a step further. A constraint of the form $\edge{A}{B}{[0, 0]}$ enforces
simultaneous execution of $A$ and $B$, making one of the events redundant from a scheduling
perspective. In this example, RMPL removes =take-pictures:end=, leaving us with three events for the
two constraints.

$$
\edge{\texttt{take-pictures:start}}{\texttt{eat-snack:start}}{[3, 7]} \edge{}{\texttt{eat-snack:end}}{[3, 7]}
$$

From an execution perspective, =eat-snack:start= both signifies the end of taking pictures and the
beginning of snacking.

Going back to the installation example, we want the execution semantics of deciding when to start,
traversing to an installation location, performing the installation, waiting for the response, and
then moving to the next installation. As described in Section [[sec:scheduling-experimental]], the delay
STNU takes the form as follows, with $\gammabar(\texttt{confirm:0:0}) = [0, 3]$.

$$
\conedge{\texttt{start:0:0}}{\texttt{traverse:0:0}}{[1, 15]} \edge{}{\texttt{install:0:0}}{[1, 14]} \conedge{}{\texttt{confirm:0:0}}{[1, 6]} \edge{}{\texttt{start:0:1}}{[2, 12]}
$$

In RMPL, we model each iteration of the procedure like so. (We use the =/0-0= numbering instead of
the =:0:0= scheme in RMPL because =:= causes errors related to lisp package exports.)

#+begin_src lisp
(define-control-program traverse/0-0 ()
  (declare (primitive)
           (duration (simple :lower-bound 1 :upper-bound 15)
                     :contingent t)))

(define-control-program install/0-0 ()
  (declare (primitive)
           (duration (simple :lower-bound 1 :upper-bound 14))))

(define-control-program confirm/0-0 ()
  (declare (primitive)
           (duration (simple :lower-bound 1 :upper-bound 6
                             :min-observation-delay 0 :max-observation-delay 3)
                     :contingent t)))

(define-control-program start/0-1 ()
  (declare (primitive)
           (duration (simple :lower-bound 2 :upper-bound 12))))

(define-control-program main ()
  (with-temporal-constraint (simple-temporal :upper-bound 108)
    (sequence (:slack nil)
      (traverse/0-0)
      (install/0-0)
      (confirm/0-0)
      (start/0-1))))
#+end_src

This results in a delay STNU of the form below (ignoring the overall upper-bound for simplicity's sake).

\begin{align*}
\conedge{\texttt{traverse/0-0:start}}{&\texttt{install/0-0:start}}{[1, 15]} \edge{}{\texttt{confirm/0-0:start}}{[1, 14]} \conedge{}{}{[1, 6]} \\
&\edge{\texttt{start/0-1:start}}{\texttt{start/0-1:end}}{[2, 12]}
\end{align*}

If we need to translate events between the two forms, we simply note that event names are shifted by
one place earlier in the delay STNU generated by RMPL.

** Action Model
<<sec:rmpl-agents>>

This section is included to expand on the features of RMPL, though note that none of these features
are required for controlling distributed agents, and were not a part of the experiments for this
research.

If we wanted to specify agents in a multi-agent control program, or if we wanted to take vehicle
dynamics into account, RMPL gives us a means for using the Common Lisp Object System (CLOS) for
defining agents, agent dynamics, and the control programs agents may execute.

An example RMPL control program with an agent is provided in Listing [[code:glider-simple]] for
completeness sake from the domain of underwater robotics.

#+name: code:glider-simple
#+caption: A snippet of an RMPL script that defines an agent and classical planning predicates and effects of a control program.
#+begin_src lisp
;; This code is a snippet from a file in the thesis code repo found at:
;;      kirk-v2/examples/glider/script.rmpl

(defclass glider ()
  ((id
    :initarg :id
    :finalp t
    :type integer
    :reader id
    :documentation
    "The ID of this glider.")
   (deployed-p
    :initform nil
    :type boolean
    :accessor deployed-p
    :documentaiton
    "A boolean stating if the glider is deployed at any point in time.")
   (destination
    :initform nil
    :type (member nil "start" "end" "science-1" "science-2")
    :accessor destination
    :documentation
    "The location to which the glider is currently heading, or NIL if it is not
    in transit.")
   (location
    :initarg :location
    :initform "start"
    :type (member nil "start" "end" "science-1" "science-2")
    :accessor location
    :documentation
    "The location where the glider is currently located, or NIL if it is not at
    a location (in transit).")))

(define-control-program move (glider to)
  (declare (primitive)
           (requires (and
                      (over :all (= (destination glider) to))))
           (effect (and
                    (at :start (= (destination glider) to))
                    (at :start (= (location glider) nil))
                    (at :end (= (destination glider) nil))
                    (at :end (= (location glider) to))))
           (duration (simple :lower-bound 10 :upper-bound 20))))
#+end_src

In Listing [[code:glider-simple]], =glider= refers to a low-powered autonomous underwater vehicle that
prefers to traverse by following ocean currents using a buoyancy engine.[fn:: The Slocum Glider is
an example: [[https://www.whoi.edu/what-we-do/explore/underwater-vehicles/auvs/slocum-glider/][https://www.whoi.edu/what-we-do/explore/underwater-vehicles/auvs/slocum-glider/.]]] We see
that we model a =glider= agent and its properties using standard CLOS. The =move= control program
then takes a =glider= and a =location= as arguments. The =(requires ...)= form is equivalent to the
preconditions of a durative action in a PDDL 2.1 [cite:@Fox2003] domain. Likewise, the =(effect
...)= form is equivalent to PDDL effects. Finally, as we saw before, the durative action also
includes a temporal constraint in its =(duration ...)= form.

Kirk is able to take RMPL as input to perform classical planning, though further discussion of it
falls outside the scope of this thesis.
