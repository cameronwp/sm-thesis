#+title: Technical Distributed

* COMMENT notes
- we could have introduced a translation layer in comms such that events with different names were translated between executives
  - oh wait we tried it and it sucked

* Coordinating Multiple Agents under Uncertain Communication
<<ch:technical-coordination>>

In this chapter, we present a novel MA framework for dynamic event scheduling with inter-agent
temporal constraints. Our framework adheres to the variable observation delay modeling framework
presented in Chapter [[ch:modeling-tn]], making it robust to uncertain communication.

Online MA coordination of event dispatching allows executives to dynamically decide when to act
given the resolution of inter- and intra-agent temporal constraints. In our formulation, each
executive has its own STNU with contingent events it expects to observe and free events it is
responsible for monitoring. We do not distinguish between contingent events that are the free events
scheduled by peer agents and contingent events from any other source in Nature. There are no
restrictions on inter-agent constraints, though they must avoid chained contingencies the same way
that vanilla, single-agent STNUs do [cite:@MMV2001].

We set forth the following requirements for the framework we contribute in this thesis.

- Executives are /not/ required to have perfect knowledge of the complete state of the world, nor
  are they required to even /agree/ on the state of the world. Rather, their knowledge should be
  consistent with the temporal constraints and observation delay modeled in their individual STNUs.
- Executives are allowed to ignore observations.
- /All/ inter-agent communications must be explicitly modeled.

To our knowledge, no such online scheduler for MA coordination has been proposed. In this chapter,
we first describe the techniques and high-level language used to model MA constraints. Next, we
define an event propagation algorithm used to guarantee that event observations match individual
agent STNUs. We finish by presenting experimental analysis of our event propagation algorithms.

** Multi-Agent Control Programs
<<sec:ma-control-programs>>

# It's hard to write MA RMPL by hand

The challenge of MA

** Event Propagation
<<sec:event-propagation>>

# TODO something about no retries here?

# Algos for graph structure of event comms

At a high level, scheduled events propagate through a simple directed graph of connected executives.
We put checks in place to ensure that cycles do not cause infinitely recursed event observations.

# #+label: def:communication-responsibility
# #+latex: \begin{defn}
# #+latex: \label{defc:communication-responsibility}
# *Communication Responsibilities*

# For a MA scheduling problem, the /communication responsibilities/ is a set of tuples $\langle p, s
# \rangle$, where:
# - $p$ is a publishing executive,
# - $s$ is a subscribing executive.
# #+latex: \end{defn}

#+label: def:communication-graph
#+latex: \begin{defn}
#+latex: \label{def:communication-graph}
*Communication Graph*

A /communication graph/ $C$ is a tuple $\langle V, E \rangle$, where:
- $V$ is a set of vertices representing peer executives,
- $E$ is a set of directed edges between $v \in V$ representing the path of event observation
  propagation,
- Each edge $e_{i} \in E$ is a pair $(o, t)$, where $o, t \in V$ represent the origin and
  termination of the edge respectively.

Loops, or self-edges, are not allowed, i.e. for any vertex $v_{i} \in V$, no single edge $e_{i} \in
E$ may both originate and terminate at $v_{i}$.
#+latex: \end{defn}

# TODO insert sample graph here

For some executive $v_{i} \in V$ with outgoing edges in $E$, $(v_{i}, v_{j})$, $\cdots$, $(v_{i},
v_{k})$, any scheduled events that $v_{i}$ assigns, whether free or contingent, are propagated to
all peer executives $v_{j}$, $\cdots$, $v_{k}$. Likewise, all contingent events received from Nature
are propagated to peers. Finally, any events $v_{i}$ receives from other agents are also relayed to
peers.

# Note that $C$ is wholly distinct from individual STNUs and inter-agent temporal constraints.

#+label: def:event-propagations
#+latex: \begin{defn}
#+latex: \label{def:event-propagations}
*Event Propagation Messages*

An /event propagation message/ $m$ is a tuple $\langle x, P \rangle$, where:
- $x$ is a set of one or more events scheduled simultaneously,
- $P \subseteq V$ is a set of executives who have already received the message.
#+latex: \end{defn}

Recognize that Definition [[def:event-propagations]] is vague in defining $x$. Event propagation
messages are passed between agents, and each agent has its own STNU. In some cases, $x$ will be free
events, in others $x$ will be contingent events. The type of event makes no difference to the
algorithm so we do not distinguish between them here.

Events that are received in $m$, $m[x]$, are handled the same as observations of contingent events
during scheduling. Lemmas [[lemma:information-fixes-bounds]], [[lemma:ignore-inf-delay]], and
[[lemma:subtract-gamma]] are applied as appropriate when the observation of $m[x]$ arrives.

# TODO clean up

# we can always ignore events
# agents are likely to receive more events than they care about

For an edge $(v_{i}, v_{j}) \in E$, it is possible that $v_{j}$ receives events that are not present
in its STNU.

Because we have not defined a temporal decoupling-like algorithm wherein an STNU for multiple-agents
is programmatically separated into individual STNUs (see the discussion of multi-agent STNUs
[cite:@Casanova2016] in Section [[sec:mastnus]]), we are reliant on human planners to write STNUs for
each agent by hand. As a result, there is no guarantee that $x$ is meaningful to a given agent.

To be more specific, there is no guarantee that any event $x_{i} \in x$ in the event propagation
message has an equivalent event in $X_{c}$ of the STNU being executed by any receiving agent $v_{j}
\in V$. If agent $v_{j}$ cannot find $x_{i}$ in their $X_{c}$, then $x_{i}$ can be ignored. As will
be discussed in Algorithm [[alg:event-propagation]], we represent $x$ using a type that can be compared
for equivalence with the events in an agent's STNUs, e.g. a list of strings.

# ODOT

We use $P$ to avoid cycles in event propagation. As will be shown in Algorithm
[[alg:event-propagation]], agent $v_{i}$ will avoid propagating $x$ to any agents in $P$. Agent $v_{i}$
will also grow $P$ when it relays $m$ to other agents by appending to $P$ itself and all outgoing
agents $v_{j}, \cdots, v_{k}$.

Timing information, e.g. timestamps, is explicitly excluded from $m$. Dynamic scheduling and the
variable-delay STNU and event observation, $\obs$, formalisms do not account for timestamps.
Instead, we expect that passing messages for event propagation between executives takes an amount of
time in the domain $\mathbb{R^{+}}$. Thus, when $v_{j}$ expects to receives an event, $x_{i} \in x$,
from $v_{i}$, the time delay can be naturally modeled in the variable-delay function,
$\gammabar({x_{i}})$, in the STNU that $v_{j}$ will execute.

If event propagation messages were to include accurate timestamps, we would need to modify the way
events are recorded during scheduling, impacting scheduling Lemmas [[lemma:information-fixes-bounds]],
[[lemma:ignore-inf-delay]], and [[lemma:subtract-gamma]]. Scheduling events in the past could also impact
controllability. For these reasons, we avoid the inclusion of timestamps in event propagation
messages.

By Definition [[def:event-propagations]], events received from other agents are no different than events
received from Nature, and no special considerations are required for scheduling.

We now walk through the process of passing messages between agents as shown in Algorithm
[[alg:event-propagation]]. We use the same /Event Propagation/ algorithm in three cases:

1. When an agent $v_{i}$ schedules free events $x$,
2. When $v_{i}$ receives an observation from Nature of contingent events $x$,
3. When $v_{i}$ receives an incoming message $m_{i}$ with contingent events $m_{i}[x]$ from another
   agent in $V$.

Let =peers= be a mutable set initialized to the terminal vertices for all $e \in E$ originating at
$v_{i}$.

In the first case, agent $v_{i}$ fulfills its responsibilities as defined in $C$ by broadcasting $x$
to its =peers=, who will receive $x$ as exogenous contingent events. The outgoing message $m_{o}$
that will be passed to =peers= will include enough information such that no agent should receive a
given $x$ more than once. To do so, we let $P$ be a set of all agents that will have observed $x$
when $m_{o}$ is received by =peers=, $P = \{ v_{i}, p~ \forall~ p \in \texttt{peers} \}$. We
finalize $m_{o} = \langle x, P \rangle$, which we simultaneously transmit to each $p$ in =peers=.
Transmission is a "fire and forget" operation, where $v_{i}$ does not wait for acknowledgment from
any $p$ that $m_{o}$ was received.

The second case plays out the same as the first, the only difference being that $x$ is itself
observed from Nature. Once again, we let $P$ be a list of $v_{i}$ and all =peers=, and then transmit
$m_{o}$ simultaneously to all =peers=.

The third case is a relay operation. Agent $v_{i}$ is responsible for propagating events $m_{i}[x]$
that it has just observed, but we want to avoid sending the events to =peers= who have already
observed them. We remove those agents from =peers= accordingly with a set difference operation:
=peers= $= \texttt{peers} - m_{i}[P]$. Likewise, we grow the list of agents who have received $x$,
which is now $P = P \cup \texttt{peers}$. Agent $v_{i}$ composes a new $m_{o} = \langle m_{i}[x], P
\rangle$ and transmits it to =peers=.

Ideally, the Event Propagation algorithm should run on a separate thread from the main scheduling
loop, else we run the risk of incurring unnecessary delays in observing and dispatching events.

#+label: alg:event-propagation
#+begin_export tex
\begin{algorithm}
\SetAlgoLined
\SetKwComment{Comment}{/*}{*/}
\SetKwFunction{Return}{return}
\SetKwInput{Input}{Input}
\SetKwInput{Algorithm}{\textsc{Event Propagation}}
\SetKwInput{Initialize}{Initialization}
\SetKwIF{If}{ElseIf}{Else}{if}{then}{else if}{else}{endif}

\Indm
\Input{Incoming message $m_{i}$; Scheduled events $x$; Self $v_{i} \in V$; Set of outgoing $\texttt{peers} \subset V$}

\Indp
\Algorithm{}
\Indp

$\texttt{peers} \gets \texttt{peers} - m_{i}[P]$\;

$P \gets \{ m_{i}[P] \} \cup \{ v_{i} \} \cup \texttt{peers}$\;

$x \gets x$ or $m_{i}[x]$\;

$m_{o} \gets \langle x, P \rangle$\;

\For{each $p$ in $\texttt{peers}$} {
    Perform a non-blocking transmission of $m_{o}$ to $p$\;
}

\caption{An event propagation algorithm that avoids recursive message passing.}
\label{alg:event-propagation}
\end{algorithm}
#+end_export

The complexity of Algorithm [[alg:event-propagation]] is trivially $O(N)$, where $N$ is the number of
executives in $V - 1$. The limiting factor to the performance of Event Propagation will be the time
it takes to transmit messages between agents, which, to reiterate, should be modeled in the delay
functions for any inter-agent temporal constraints.

** Experimental Analysis
<<sec:ma-experimental>>

# TODO HTTP technically has more than one message passed. discuss other protocols and when you would want to use them here?

We performed two analyses of the Event Propagation algorithm. The first was a hardware demonstration
performed on a Barrett WAM manipulator in the MERS lab. The second is a massively multi-agent
simulation. Both will be described below.

*** Hardware Demonstration

# TODO need pics and such

We envision a scenario with an astronaut and a robot coordinating on the lunar surface. The
astronaut is performing scientific exploration while the robot performs remote construction tasks.
The concept of operations allows for the astronaut to use a rover to traverse away from the robot in
search of promising scientific samples. Due to the position of surface relays and general
uncertainty in lunar topology, there is an uncertain time delay between agents.

Bandwidth between Mission Control on Earth and the Moon is limited. There are low and high bandwidth
communications available to both agents. Low bandwidth is responsible for transmitting critical data
(e.g. suit telemetry), while high bandwidth communications are reserved for purposes such as video
calls and large dumps of scientific data. It is not possible for both the astronaut and the robot to
use high bandwidth communications simultaneously. Thus, there is a need for the agents to coordinate
such that they make effective use of high bandwidth communications without stepping on each others
toes, so to speak.

Our demonstration hones in on a point in an EVA where there is substantial time delay between the
astronaut and robot.

*** Massively Multi-Agent Simulation
