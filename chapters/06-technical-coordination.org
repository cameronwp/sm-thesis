#+title: Technical Distributed

* COMMENT notes
- we could have introduced a translation layer in comms such that events with different names were translated between executives
  - oh wait we tried it and it sucked

* Coordinating Multiple Agents under Uncertain Communication
<<ch:technical-coordination>>

In this chapter, we present a novel MA framework for dynamic event scheduling with inter-agent
temporal constraints. Our framework adheres to the variable observation delay modeling framework
presented in Chapter [[ch:modeling-tn]], making it robust to uncertain communication.

Online MA coordination of event dispatching allows executives to dynamically decide when to act
given the resolution of inter- and intra-agent temporal constraints. In our formulation, each
executive has its own STNU with contingent events it expects to observe and free events it is
responsible for monitoring. We do not distinguish between contingent events that are the free events
scheduled by peer agents and contingent events from any other source in Nature. There are no
restrictions on inter-agent constraints, though they must avoid chained contingencies the same way
that vanilla, single-agent STNUs do [cite:@MMV2001].

We set forth the following requirements for the framework we contribute in this thesis.

- Executives are /not/ required to have perfect knowledge of the complete state of the world, nor
  are they required to even /agree/ on the state of the world. Rather, their knowledge should be
  consistent with the temporal constraints and observation delay modeled in their individual STNUs.
- Executives are allowed to ignore observations.
- /All/ inter-agent communications must be explicitly modeled.

To our knowledge, no such online scheduler for MA coordination has been proposed. In this chapter,
we first describe the techniques and high-level language used to model MA constraints. Next, we
define an event propagation algorithm used to guarantee that event observations match individual
agent STNUs. We finish by presenting experimental analysis of our event propagation algorithms.

** Multi-Agent Control Programs
<<sec:ma-control-programs>>

# It's hard to write MA RMPL by hand

The challenge of MA

** Event Propagation
<<sec:event-propagation>>

# TODO something about no retries here?

# Algos for graph structure of event comms

At a high level, scheduled events propagate through a simple directed graph of connected executives.
We put checks in place to ensure that cycles do not cause infinitely recursed event observations.

# #+label: def:communication-responsibility
# #+latex: \begin{defn}
# #+latex: \label{defc:communication-responsibility}
# *Communication Responsibilities*

# For a MA scheduling problem, the /communication responsibilities/ is a set of tuples $\langle p, s
# \rangle$, where:
# - $p$ is a publishing executive,
# - $s$ is a subscribing executive.
# #+latex: \end{defn}

#+label: def:communication-graph
#+latex: \begin{defn}
#+latex: \label{def:communication-graph}
*Communication Graph*

A /communication graph/ $C$ is a tuple $\langle V, E \rangle$, where:
- $V$ is a set of vertices representing peer executives,
- $E$ is a set of directed edges between $v \in V$ representing the path of event observation
  propagation,
- Each edge $e_{i} \in E$ is a pair $(o, t)$, where $o, t \in V$ represent the origin and
  termination of the edge respectively.

Loops, or self-edges, are not allowed, i.e. for any vertex $v_{i} \in V$, no edge $e_{i} \in E$ may
originate and terminate at $v_{i}$.
#+latex: \end{defn}

# TODO insert sample graph here

For some executive $v_{i} \in V$ with outgoing edges in $E$, $(v_{i}, v_{j})$, $\cdots$, $(v_{i},
v_{k})$, any scheduled events that $v_{i}$ assigns, whether free or contingent, are propagated to
all peer executives $v_{j}$, $\cdots$, $v_{k}$.

# Note that $C$ is wholly distinct from individual STNUs and inter-agent temporal constraints.

#+label: def:event-propagations
#+latex: \begin{defn}
#+latex: \label{def:event-propagations}
*Event Propagation Messages*

An /event propagation message/ $m$ is a tuple $\langle x, P \rangle$, where:
- $x$ is a set of one or more events scheduled simultaneously,
- $P \subseteq V$ is a set of executives who have already received the message.
#+latex: \end{defn}

Recognize that Definition [[def:event-propagations]] is vague in defining $x$. Event propagation
messages are passed between agents, and each agent has its own STNU. In some cases, $x$ will be free
events, in others $x$ will be contingent events. The type of event makes no difference to the
algorithm so we do not distinguish between them here.

# TODO should this be said earlier? more clearly? more emphasis? give relation to scheduling lemmas?
Events that are received in $m$ are treated the same as observations of contingent events during
scheduling.

For an edge $(v_{i}, v_{j}) \in E$, it is possible that $v_{j}$ receives events that are not present
in its STNU.

Because we have not defined a temporal decoupling-like algorithm wherein an STNU for multiple-agents
is programmatically separated into individual STNUs (see the discussion of multi-agent STNUs
[cite:@Casanova2016] in Section [[sec:mastnus]]), we are reliant on human planners to write STNUs for
each agent by hand. As a result, there is no guarantee that $x$ is meaningful to a given agent.

To be more specific, there is no guarantee that any event $x_{i} \in x$ in the event propagation
message has an equivalent event in $X_{c}$ of the STNU being executed by any receiving agent $v_{j}
\in V$. If agent $v_{j}$ cannot find $x_{i}$ in their $X_{c}$, then $x_{i}$ can be ignored. As will
be discussed in Algorithm [[alg:event-propagation]], we represent $x$ using a type that can be compared
for equivalence with the events in an agent's STNUs, e.g. a list of strings.

We use $P$ to avoid cycles in event propagation. As will be shown in Algorithm
[[alg:event-propagation]], agent $v_{i}$ will avoid propagating $x$ to any agents in $P$. Agent $v_{i}$
will also grow $P$ when it relays $m$ to other agents by appending to $P$ itself and all outgoing
agents $v_{j}, \cdots, v_{k}$.

Timing information, e.g. timestamps, is explicitly excluded from $m$. Dynamic scheduling and the
variable-delay STNU and event observation, $\obs$, formalisms do not account for timestamps.
Instead, we expect that passing messages for event propagation between executives takes an amount of
time in the domain $\mathbb{R^{+}}$. Thus, when $v_{j}$ expects to receives an event, $x_{i} \in x$,
from $v_{i}$, the time delay can be naturally modeled in the variable-delay function,
$\gammabar({x_{i}})$, in the STNU that $v_{j}$ will execute.

If event propagation messages were to include accurate timestamps, we would need to modify the way
events are recorded during scheduling, impacting scheduling Lemmas [[lemma:information-fixes-bounds]],
[[lemma:ignore-inf-delay]], and [[lemma:subtract-gamma]]. Scheduling events in the past could also impact
controllability. For these reasons, we avoid the inclusion of timestamps in event propagation
messages.

By Definition [[def:event-propagations]], events received from other agents are no different than events
received from Nature, and no special considerations are required for scheduling.

We now walk through the process of passing messages between agents as shown in Algorithm
[[alg:event-propagation]]. We use the same /Event Propagation/ algorithm in three cases:

1. When an agent $v_{i}$ schedules free events $x$,
2. When $v_{i}$ receives an observation from Nature of contingent events $x$,
3. When $v_{i}$ receives an incoming message $m_{i}$ with contingent events $m_{i}[x]$ from another
   agent in $V$.

Let =peers= be the terminal vertices for all $e \in E$ originating at $v_{i}$.

In the first case, agent $v_{i}$ fulfills its responsibilities as defined in $C$ by broadcasting $x$
to its =peers=, who will receive $x$ as exogenous contingent events. The outgoing message $m_{o}$
that will be passed to =peers= will include enough information such that no agent should receive a
given $x$ more than once. We let $P$ be a list of $v_{i}$ and all =peers=. We finalize $m_{o} =
\langle x, P \rangle$, which we simultaneously transmit to each $p$ in =peers=. Transmission is a
"fire and forget" operation, where $v_{i}$ does not wait for acknowledgment from any $p$ that
$m_{o}$ was received.

The second case plays out the same as the first, the only difference being that $x$ is itself
observed from Nature. Once again, we let $P$ be a list of $v_{i}$ and all =peers=, and then transmit
$m_{o}$ simultaneously to all =peers=.

The third case is a relay operation. Agent $v_{i}$ is responsible for propagating events $m_{i}[x]$
that it has just observed, but we want to avoid

It is possible that $v_{i}$ is a =peer= of one or more of its =peers=, so it includes

# TODO $m$ or $x$?

#+label: alg:event-propagation
#+begin_export tex
\begin{algorithm}
\label{alg:event-propagation}
\SetAlgoLined
\SetKwFunction{Return}{return}
\SetKwInput{Input}{Input}
\SetKwInput{Output}{Output}
\SetKwInput{Algorithm}{\textsc{Event Propagation}}
\SetKwInput{Initialize}{Initialization}
\SetKwIF{If}{ElseIf}{Else}{if}{then}{else if}{else}{endif}

\Indm
\Input{Event propagation message $m$; Scheduled events $x$; Self $v_{i} \in V$; Set of outgoing $\texttt{peers} \subset V$}

\Indp
\Algorithm{}
\Indp

$x \gets x$ or $m[x]$\;

$P \gets x[P] \cup v_{i} \cup \texttt{peers}$\;

$m \gets \langle x, P \rangle$\;

\For{each $p \in \texttt{peers}$} {
    Add lower-bound edge $\edge{E}{Z}{-t}$\;
}

For each event $X$, update $D(X, Z)$ using Dijkstra Single-Sink Shortest Paths\;

\For{each event $E \in \texttt{Exec}$} {
    Add upper-bound edge $\edge{Z}{E}{t}$\;
}
For each event $X$, update $D(Z, X)$ using Dijkstra Single-Source Shortest Paths\;
\caption{An event propagation algorithm that avoids recursive message passing.}
\label{alg:fast-ex-update}
\end{algorithm}
#+end_export


# TODO HTTP technically has more than one message passed. discuss other protocols and when you would want to use them here?

** Experimental Analysis
<<sec:ma-experimental>>

*** Hardware Demonstrations

*** Massively Multi-Agent Simulation
