#+title: Technical Distributed

* COMMENT notes
- we could have introduced a translation layer in comms such that events with different names were translated between executives
  - oh wait we tried it and it sucked

* Coordinating Multiple Agents under Uncertain Communication
<<ch:technical-coordination>>

In this chapter, we present a novel MA framework for dynamic event scheduling with inter-agent
temporal constraints. Our framework adheres to the variable observation delay modeling framework
presented in Chapter [[ch:modeling-tn]], making it robust to uncertain communication.

Online MA coordination of event dispatching allows executives to dynamically decide when to act
given the resolution of inter- and intra-agent temporal constraints. In our formulation, each
executive has its own STNU with contingent events it expects to observe and free events it is
responsible for monitoring. We do not distinguish between contingent events that are the free events
scheduled by peer agents and contingent events from any other source in Nature. There are no
restrictions on inter-agent constraints, though they must avoid chained contingencies the same way
that vanilla, single-agent STNUs do [cite:@MMV2001].

We set forth the following requirements for the framework we contribute in this thesis.

- Executives are /not/ required to have perfect knowledge of the complete state of the world, nor
  are they required to even /agree/ on the state of the world. Rather, their knowledge should be
  consistent with the temporal constraints and observation delay modeled in their individual STNUs.
- Executives are allowed to ignore observations.
- /All/ inter-agent communications must be explicitly modeled.

To our knowledge, no such online scheduler for MA coordination has been proposed. In this chapter,
we first present a grounded Artemis-like scenario to motivate coordination. Next, we describe a
modeling framework for MA control programs that is necessary for establishing coordination between
agents. Next, we define an event propagation algorithm used to guarantee that event observations
match individual agent STNUs. We finish by presenting experimental analysis of our event propagation
algorithms, and the results of hardware demonstrations of Delay Kirk using a robotic arm and a
simulated astronaut.

** Motivating Scenario from EVAs

We envision a scenario with an astronaut and a robot coordinating on the lunar surface. The
astronaut is performing scientific exploration while the robot performs remote construction tasks.
The concept of operations allows for the astronaut to use a rover to traverse away from the robot in
search of promising scientific samples. Due to the position of surface relays and general
uncertainty in lunar topology, there is an uncertain time delay between agents.

Bandwidth between Mission Control on Earth and the Moon is limited. There are low and high bandwidth
communications available to both agents. Low bandwidth is responsible for transmitting critical data
(e.g. suit telemetry), while high bandwidth communications are reserved for purposes such as video
calls and large dumps of scientific data. It is not possible for both the astronaut and the robot to
use high bandwidth communications simultaneously. Thus, there is a need for the agents to coordinate
such that they make effective use of high bandwidth communications without stepping on each others
toes, so to speak.

We hone in on a point in an EVA where there is substantial time delay between the astronaut and
robot. The astronaut has set out far from the robot in search of scientifically interesting rock
samples. Meanwhile, the robot is preparing to perform a drilling operation. The astronaut's sample
collection work involves spectroscopy and video imagery, which is being sent to Mission Control
using the high bandwidth connection. It will take between 15 and 30 minutes to downlink all the
data. As soon as sample collection is over, the robot can use the high bandwidth connection to
perform a drilling operation.

We say that the astronaut "owns," or is responsible for sharing observations of, the start and end
of the experiment, while the robot similarly owns the drilling operation.

# The astronaut and robot need to agree on the order of events relevant to coordination.

** Multi-Agent Control Programs
<<sec:ma-control-programs>>

# It's hard to write MA RMPL by hand

# TODO is what I'm describing here more of an RMPL restriction? why did (:slack t) not work?
# TODO what this is describing is more of a problem with (:slack nil)?

# TODO Something about =sync= episodes after observation delay
# I think we basically say we had to work around limitations in RMPL here

# TODO paragraph probably needs to be broken up. part of the claim needs to be moved into the chapter intro
This thesis introduces challenges in writing control programs for multiple agents who need to
coordinate. We do not claim to solve all aspects of coordination, rather we present a framework for
simple scenarios with the key feature being that agents need to agree on the /order/ of a subset of
events. We start by presenting an example of inter-agent temporal constraints, followed by defining
a modeling framework for guaranteeing that agents agree about the order of events in their
respective partial histories. To the best of our knowledge, we are unaware of any other MA framework
for coordinating the order of event histories.

# TODO do we need to define "semantically similar"?
Consider two agents, =agent1= and =agent2=, that are scheduling STNUs $S_{1}$ and $S_{2}$
respectively. $S_{1}$ and $S_{2}$ share a subset of semantically similar episodes, $e_{1}$ and
$e_{2}$. =agent1= "owns" $e_{1}$, meaning it is responsible for scheduling the free event
$e_{1}$​-start and observing the contingent event $e_{1}$​-end, while =agent2= owns $e_{2}$.

# TODO this is like the EVA scenario like so...

# TODO do we need to add overall constraints for time pressure?

A simplified MA view of the constraints is as follows.

$$
\conedge{e_{1}\text{-start}}{e_{1}\text{-end}}{[15, 30]}
\edge{}{e_{2}\text{-start}}{[0, \infty]}
\conedge{}{e_{2}\text{-end}}{[22, 26]}
$$

From =agent1='s perspective, $S_{1}$ models the following constraints. We add a =noop= start event,
$Z$, to simplify coordination.

$$
\edge{Z}{e_{1}\text{-start}}{[0, 0]}
\conedge{}{e_{1}\text{-end}}{[15, 30]}
\conedge{}{e_{2}\text{-start}}{[0, \infty]}
\conedge{}{e_{2}\text{-end}}{[22, 26]}
$$

$S_{2}$ is then modeled as follows.

$$
\conedge{Z}{e_{1}\text{-start}}{[0, 0]}
\conedge{}{e_{1}\text{-end}}{[15, 30]}
\edge{}{e_{2}\text{-start}}{[0, \infty]}
\conedge{}{e_{2}\text{-end}}{[22, 26]}
$$

For the sake of controllability of $S_{1}$ and $S_{2}$, we would simply add $[0, 0]$ free
constraints between consecutive contingent constraints.

We will walk through scheduling this scenario from the perspective of both agents. First, we
describe their actions in the case that there is no communication delay, then we introduce the need
for communication, and finally we add delay to communications. This scenario will motivate our
analysis of the challenges that arise in MA control programs.

# TODO maybe we don't even need to include the "instantaneous knowledge" version of events here
If both agents have perfect knowledge of the world (instantaneous knowledge of events), scheduling
is trivial. =agent1= and =agent2= execute $Z$ simultaneously. =agent1= schedules $e_{1}$​-start and
=agent2= instantaneously receives an observation of $e_{1}$​-start. $e_{1}$​-end arrives in $[15, 30]$
later, which again, both agents observe simultaneously. Now =agent2= is free to act. It schedules
$e_{2}$​-start, which =agent1= observes instantaneously. $e_{2}$​-end arrives $[22, 26]$ later and is
observed simultaneously by both agents.

Now, we enforce that =agent1= "owns" $e_{1}$ and is the only agent that can observe it directly.
Likewise, =agent2= owns $e_{2}$. In order for an agent to learn about an episode they do not own,
they must receive a communication from the agent who does. After =agent1= schedules $e_{1}$​-start,
it must send a message to =agent2=. =agent2= receives said message, which it interprets as an
observation of $e_{1}$​-start. If communications are instantaneous, the partial histories of both
agents agree on the assignment of $e_{1}$​-start. Later $e_{1}$​-end is observed by =agent1=, who is
then responsible for relaying a communication to =agent2= indicating that it is safe to assign
$e_{1}$​-end. =agent2= is now free to schedule $e_{2}$​-start, and follows the same pattern of sending
messages that events have been scheduled to =agent1=. After all events have been scheduled, the
histories of =agent1= and =agent2= still agree on the times assigned to each event.

We now show that adding delay to the communications between agents forces us to add /synthetic/
episodes to $S_{1}$ and $S_{2}$ to maintain event ownership. We now say that for $S_{2}$,
$\gammabar(e_{2}\text{-end}) = [5, 15]$. In other words, =agent2= learns that =agent1= has finished
$e_{2}$ some time in $[5, 15]$ after =agent1= has made the same assignment.

Once again, =agent1= schedules $e_{1}$​-start and sends a message to =agent2=. Unlike before, their
partial histories no longer match because =agent2= will assign $e_{1}$​-start to some time in $[5,
15]$ after =agent1=.

Adding communication introduces a coordination challenge, even when said communication is
instantaneous. Once again, we assume both agents execute $Z$ simultaneously. When =agent1= schedules
$e_{1}$​-start, it must take the additional

We define coordination as sharing an understanding of when their peers have scheduled a subset of
events. To maintain consistency, we need to maintain the order of events. i.e.

** Event Propagation
<<sec:event-propagation>>

# TODO something about no retries here?

# Algos for graph structure of event comms

At a high level, scheduled events propagate through a simple directed graph of connected executives.
We put checks in place to ensure that cycles do not cause infinitely recursed event observations.

# #+label: def:communication-responsibility
# #+latex: \begin{defn}
# #+latex: \label{defc:communication-responsibility}
# *Communication Responsibilities*

# For a MA scheduling problem, the /communication responsibilities/ is a set of tuples $\langle p, s
# \rangle$, where:
# - $p$ is a publishing executive,
# - $s$ is a subscribing executive.
# #+latex: \end{defn}

#+label: def:communication-graph
#+latex: \begin{defn}
#+latex: \label{def:communication-graph}
*Communication Graph*

A /communication graph/ $C$ is a tuple $\langle V, E \rangle$, where:
- $V$ is a set of vertices representing peer executives,
- $E$ is a set of directed edges between $v \in V$ representing the path of event observation
  propagation,
- Each edge $e_{i} \in E$ is a pair $(o, t)$, where $o, t \in V$ represent the origin and
  termination of the edge respectively.

Loops, or self-edges, are not allowed, i.e. for any vertex $v_{i} \in V$, no single edge $e_{i} \in
E$ may both originate and terminate at $v_{i}$.
#+latex: \end{defn}

# TODO insert sample graph here

For some executive $v_{i} \in V$ with outgoing edges in $E$, $(v_{i}, v_{j})$, $\cdots$, $(v_{i},
v_{k})$, any scheduled events that $v_{i}$ assigns, whether free or contingent, are propagated to
all peer executives $v_{j}$, $\cdots$, $v_{k}$. Likewise, all contingent events received from Nature
are propagated to peers. Finally, any events $v_{i}$ receives from other agents are also relayed to
peers.

# Note that $C$ is wholly distinct from individual STNUs and inter-agent temporal constraints.

#+label: def:event-propagations
#+latex: \begin{defn}
#+latex: \label{def:event-propagations}
*Event Propagation Messages*

An /event propagation message/ $m$ is a tuple $\langle x, P \rangle$, where:
- $x$ is a set of one or more events scheduled simultaneously,
- $P \subseteq V$ is a set of executives who have already received the message.
#+latex: \end{defn}

Recognize that Definition [[def:event-propagations]] is vague in defining $x$. Event propagation
messages are passed between agents, and each agent has its own STNU. In some cases, $x$ will be free
events, in others $x$ will be contingent events. The type of event makes no difference to the
algorithm so we do not distinguish between them here.

Events that are received in $m$, $m[x]$, are handled the same as observations of contingent events
during scheduling. Lemmas [[lemma:information-fixes-bounds]], [[lemma:ignore-inf-delay]], and
[[lemma:subtract-gamma]] are applied as appropriate when the observation of $m[x]$ arrives.

# TODO clean up

# we can always ignore events
# agents are likely to receive more events than they care about

For an edge $(v_{i}, v_{j}) \in E$, it is possible that $v_{j}$ receives events that are not present
in its STNU.

Because we have not defined a temporal decoupling-like algorithm wherein an STNU for multiple-agents
is programmatically separated into individual STNUs (see the discussion of multi-agent STNUs
[cite:@Casanova2016] in Section [[sec:mastnus]]), we are reliant on human planners to write STNUs for
each agent by hand. As a result, there is no guarantee that $x$ is meaningful to a given agent.

To be more specific, there is no guarantee that any event $x_{i} \in x$ in the event propagation
message has an equivalent event in $X_{c}$ of the STNU being executed by any receiving agent $v_{j}
\in V$. If agent $v_{j}$ cannot find $x_{i}$ in their $X_{c}$, then $x_{i}$ can be ignored. As will
be discussed in Algorithm [[alg:event-propagation]], we represent $x$ using a type that can be compared
for equivalence with the events in an agent's STNUs, e.g. a list of strings.

# ODOT

We use $P$ to avoid cycles in event propagation. As will be shown in Algorithm
[[alg:event-propagation]], agent $v_{i}$ will avoid propagating $x$ to any agents in $P$. Agent $v_{i}$
will also grow $P$ when it relays $m$ to other agents by appending to $P$ itself and all outgoing
agents $v_{j}, \cdots, v_{k}$.

Timing information, e.g. timestamps, is explicitly excluded from $m$. Dynamic scheduling and the
variable-delay STNU and event observation, $\obs$, formalisms do not account for timestamps.
Instead, we expect that passing messages for event propagation between executives takes an amount of
time in the domain $\mathbb{R^{+}}$. Thus, when $v_{j}$ expects to receives an event, $x_{i} \in x$,
from $v_{i}$, the time delay can be naturally modeled in the variable-delay function,
$\gammabar({x_{i}})$, in the STNU that $v_{j}$ will execute.

If event propagation messages were to include accurate timestamps, we would need to modify the way
events are recorded during scheduling, impacting scheduling Lemmas [[lemma:information-fixes-bounds]],
[[lemma:ignore-inf-delay]], and [[lemma:subtract-gamma]]. Scheduling events in the past could also impact
controllability. For these reasons, we avoid the inclusion of timestamps in event propagation
messages.

By Definition [[def:event-propagations]], events received from other agents are no different than events
received from Nature, and no special considerations are required for scheduling.

We now walk through the process of passing messages between agents as shown in Algorithm
[[alg:event-propagation]]. We use the same /Event Propagation/ algorithm in three cases:

1. When an agent $v_{i}$ schedules free events $x$,
2. When $v_{i}$ receives an observation from Nature of contingent events $x$,
3. When $v_{i}$ receives an incoming message $m_{i}$ with contingent events $m_{i}[x]$ from another
   agent in $V$.

Let =peers= be a mutable set initialized to the terminal vertices for all $e \in E$ originating at
$v_{i}$.

In the first case, agent $v_{i}$ fulfills its responsibilities as defined in $C$ by broadcasting $x$
to its =peers=, who will receive $x$ as exogenous contingent events. The outgoing message $m_{o}$
that will be passed to =peers= will include enough information such that no agent should receive a
given $x$ more than once. To do so, we let $P$ be a set of all agents that will have observed $x$
when $m_{o}$ is received by =peers=, $P = \{ v_{i}, p~ \forall~ p \in \texttt{peers} \}$. We
finalize $m_{o} = \langle x, P \rangle$, which we simultaneously transmit to each $p$ in =peers=.
Transmission is a "fire and forget" operation, where $v_{i}$ does not wait for acknowledgment from
any $p$ that $m_{o}$ was received.

The second case plays out the same as the first, the only difference being that $x$ is itself
observed from Nature. Once again, we let $P$ be a list of $v_{i}$ and all =peers=, and then transmit
$m_{o}$ simultaneously to all =peers=.

The third case is a relay operation. Agent $v_{i}$ is responsible for propagating events $m_{i}[x]$
that it has just observed, but we want to avoid sending the events to =peers= who have already
observed them. We remove those agents from =peers= accordingly with a set difference operation:
=peers= $= \texttt{peers} - m_{i}[P]$. Likewise, we grow the list of agents who have received $x$,
which is now $P = P \cup \texttt{peers}$. Agent $v_{i}$ composes a new $m_{o} = \langle m_{i}[x], P
\rangle$ and transmits it to =peers=.

Ideally, the Event Propagation algorithm should run on a separate thread from the main scheduling
loop, else we run the risk of incurring unnecessary delays in observing and dispatching events.

#+label: alg:event-propagation
#+begin_export tex
\begin{algorithm}
\SetAlgoLined
\SetKwComment{Comment}{/*}{*/}
\SetKwFunction{Return}{return}
\SetKwInput{Input}{Input}
\SetKwInput{Algorithm}{\textsc{Event Propagation}}
\SetKwInput{Initialize}{Initialization}
\SetKwIF{If}{ElseIf}{Else}{if}{then}{else if}{else}{endif}

\Indm
\Input{Incoming message $m_{i}$; Scheduled events $x$; Self $v_{i} \in V$; Set of outgoing $\texttt{peers} \subset V$}

\Indp
\Algorithm{}
\Indp

$\texttt{peers} \gets \texttt{peers} - m_{i}[P]$\;

$P \gets \{ m_{i}[P] \} \cup \{ v_{i} \} \cup \texttt{peers}$\;

$x \gets x$ or $m_{i}[x]$\;

$m_{o} \gets \langle x, P \rangle$\;

\For{each $p$ in $\texttt{peers}$} {
    Perform a non-blocking transmission of $m_{o}$ to $p$\;
}

\caption{An event propagation algorithm that avoids recursive message passing.}
\label{alg:event-propagation}
\end{algorithm}
#+end_export

The complexity of Algorithm [[alg:event-propagation]] is trivially $O(N)$, where $N$ is the number of
executives in $V - 1$. The limiting factor to the performance of Event Propagation will be the time
it takes to transmit messages between agents, which, to reiterate, should be modeled in the delay
functions for any inter-agent temporal constraints.

** Experimental Analysis
<<sec:ma-experimental>>

# TODO HTTP technically has more than one message passed. discuss other protocols and when you would want to use them here?

We performed two analyses of the Event Propagation algorithm. The first was a hardware demonstration
performed on a Barrett WAM manipulator in the MERS lab. The second is a massively multi-agent
simulation. Both will be described below.

*** Hardware Demonstration

# TODO need pics and such

We built a demonstration of the motivating scenario of this thesis in our lab using a Barrett WAM
manipulator representing the robot, and Valve Steam Deck representing the astronaut.

Each agent has their own RMPL control program, which we include in Listings [[code:astronaut-rmpl]] and
[[code:robot-rmpl]]. Note that each control program is nearly identical. The control programs related to
the high bandwidth handoff, =human-downlink-science=, =sync=, and =robot-drilling=, are nearly
identical, differing in observation delay and whether the =sync= event is controllable. Adding
observation delay reflects uncertain communication between the agents, while the =sync= activity
serves to keep the STNUs of the agents aligned.

#+name: code:astronaut-rmpl
#+caption: The control program the astronaut uses while collecting and downlinking scientific data.
#+begin_src lisp
;;;; -*- Mode: common-lisp; -*-

(defpackage #:scenario1)

(in-package #:scenario1)

(define-control-program human-downlink-science ()
  (declare (primitive)
           (duration (simple :lower-bound 15 :upper-bound 30)
                     :contingent t)))

(define-control-program sync ()
  (declare (primitive)
           (duration (simple :lower-bound 5 :upper-bound 15
                             :min-observation-delay 0
                             :max-observation-delay 1)
                     :contingent t)))

(define-control-program robot-drilling ()
  (declare (primitive)
           (duration (simple :lower-bound 22 :upper-bound 26
                             :min-observation-delay 0
                             :max-observation-delay 2)
                     :contingent t)))

(define-control-program human-closeout ()
  (declare (primitive)
           (duration (simple :lower-bound 10 :upper-bound 30))))

(define-control-program main ()
  (with-temporal-constraint (simple-temporal :upper-bound 480)
    (sequence (:slack nil)
      (human-downlink-science)
      (sync)
      (robot-drilling)
      (human-closeout))))
#+end_src

#+name: code:robot-rmpl
#+caption: The control program the robot uses to decide when to act with respect to learning the astronaut has finished collecting scientific data.
#+begin_src lisp
;;;; -*- Mode: common-lisp; -*-

(defpackage #:scenario1)

(in-package #:scenario1)

(define-control-program human-downlink-science ()
  (declare (primitive)
           (duration (simple :lower-bound 15 :upper-bound 30
                             :min-observation-delay 5
                             :max-observation-delay 15)
                     :contingent t)))

(define-control-program sync ()
  (declare (primitive)
           (duration (simple :lower-bound 5 :upper-bound 15))))

(define-control-program robot-drilling ()
  (declare (primitive)
           (duration (simple :lower-bound 22 :upper-bound 26
                             :min-observation-delay 0
                             :max-observation-delay 1)
                     :contingent t)))

(define-control-program robot-poweroff ()
  (declare (primitive)
           (duration (simple :lower-bound 10 :upper-bound 30))))


(define-control-program main ()
  (with-temporal-constraint (simple-temporal :upper-bound 480)
    (sequence (:slack nil)
      (human-downlink-science)
      (sync)
      (robot-drilling)
      (robot-poweroff))))
#+end_src

*** Massively Multi-Agent Simulation
